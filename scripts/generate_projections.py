#!/usr/bin/env python3
"""
LonelyCat Projection Tool - Cognition Compiler

Purpose: Transform agent/ cognition layer into tool-specific projections
Philosophy: agent/ = single source of truth, projections = read-only

Usage:
    python scripts/generate_projections.py

Outputs:
    - AGENTS.md (generic agent instructions)
    - CLAUDE.md (Claude Code specific)
    - .cursor/rules/*.mdc (Cursor IDE rules)
"""

import os
import yaml
from pathlib import Path
from datetime import datetime

# Repo root
REPO_ROOT = Path(__file__).parent.parent
AGENT_DIR = REPO_ROOT / "agent"
OUTPUT_DIR = REPO_ROOT


def read_file(path: Path) -> str:
    """Read file content."""
    if not path.exists():
        return f"<!-- File not found: {path} -->"
    return path.read_text(encoding="utf-8")


def read_yaml_file(path: Path) -> dict:
    """Read YAML file, handling multiple documents."""
    if not path.exists():
        return {}

    content = path.read_text(encoding="utf-8")

    # Split by --- to handle multiple YAML documents
    # policies/default.yaml has multiple --- separators
    documents = []
    for doc in yaml.safe_load_all(content):
        if doc:
            documents.append(doc)

    # Merge all documents into one dict
    merged = {}
    for doc in documents:
        if isinstance(doc, dict):
            merged.update(doc)

    return merged


def extract_yaml_frontmatter(content: str) -> dict:
    """Extract YAML frontmatter from Markdown."""
    if not content.startswith("---"):
        return {}

    parts = content.split("---", 2)
    if len(parts) < 3:
        return {}

    try:
        return yaml.safe_load(parts[1])
    except yaml.YAMLError:
        return {}


def extract_section(content: str, section_title: str) -> str:
    """Extract a section from Markdown by heading."""
    lines = content.split("\n")
    in_section = False
    section_lines = []

    for line in lines:
        if line.startswith("#") and section_title.lower() in line.lower():
            in_section = True
            section_lines.append(line)
            continue

        if in_section:
            if line.startswith("#") and not line.startswith(f"#{' ' * (line.count('#', 0, 10) - 1)}"):
                # Hit next top-level heading
                break
            section_lines.append(line)

    return "\n".join(section_lines)


def generate_agents_md():
    """Generate AGENTS.md - Generic agent instructions."""

    print("Generating AGENTS.md...")

    # Read source files
    project_content = read_file(AGENT_DIR / "project.md")
    architecture_content = read_file(AGENT_DIR / "architecture.md")
    policies_path = AGENT_DIR / "policies" / "default.yaml"

    # Extract metadata
    project_meta = extract_yaml_frontmatter(project_content)
    arch_meta = extract_yaml_frontmatter(architecture_content)

    # Load policies YAML (handles multiple documents)
    policies = read_yaml_file(policies_path)

    # Build AGENTS.md
    output = f"""# LonelyCat Agent Instructions

> **Generated from**: `agent/` cognition layer
> **Last Updated**: {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}
> **[WARN]ï¸ DO NOT EDIT THIS FILE MANUALLY** - Edit `agent/*` and regenerate

---

## ðŸŽ¯ Project Overview

**Name**: {project_meta.get('project_name', 'LonelyCat')}
**Tagline**: {project_meta.get('tagline', 'Self-Evolving Local AgentOS')}
**Phase**: {project_meta.get('phase', 'Phase 0')}
**Status**: {project_meta.get('status', 'active_development')}

**Primary Objective**: {project_meta.get('objectives', {}).get('primary', 'Build a local-first AI agent platform')}

---

## ðŸ—ï¸ Architecture (5 Layers)

{extract_section(architecture_content, 'LAYERS')}

---

## ðŸš« FORBIDDEN PATHS (Never Modify)

```yaml
{yaml.dump(policies.get('forbidden_paths', []), default_flow_style=False)}
```

**Violation**: Immediate abort + audit log

---

## âœ… WRITE-ALLOWED PATHS

```yaml
{yaml.dump(policies.get('write_allowed_paths', []), default_flow_style=False)}
```

---

## âš–ï¸ RISK LEVELS

### L0 - Read Only (No Approval)
- web.search, web.fetch, memory.list_facts
- read_file, list_directory

### L1 - Write (Approval Required in Phase 0)
- memory.propose, skill.python.run
- write_file, create_directory

### L2 - Execute (Always Requires Approval)
- host.execute_command, host.apply_patch
- execute_shell, modify_database

### L3 - Destructive (Double Confirmation)
- host.delete_database, git.reset_hard
- drop_table, delete_branch

---

## ðŸ“‹ WRITEGATE RULES (Phase 1+)

**When Required**:
- Modifying `apps/**/*.py`, `packages/**/*.py`
- Changing `pyproject.toml`, `package.json`
- Any code/config modification

**Flow**:
1. Create **ChangePlan** (objective, affected_files, risk, rollback)
2. User approves plan
3. Generate **ChangeSet** (diffs)
4. User approves diffs
5. Apply atomically
6. Verify (tests pass)
7. Record in audit

---

## ðŸ” HOW TO QUERY

### Find Code
```python
# Use Grep for patterns
Grep(pattern="accept_proposal", path="packages/memory")

# Or read architecture docs
Read agent/architecture.md -> "Where to Find Things"
```

### Check Permissions
1. Check `forbidden_paths` -> If match, ABORT
2. Check `read_only_paths` -> Need approval
3. Check `risk_levels` -> Determine approval requirement
4. Check `writegate_rules` -> Generate ChangePlan if needed

### Propose Changes
```
Phase 0: Explain what should change (cannot modify directly)
Phase 1+: Create ChangePlan -> User approval -> Apply via WriteGate
```

---

## ðŸŽ“ MEMORY LIFECYCLE

```
Proposal (pending)
    â†“ (confidence >= 0.85 + AUTO_ACCEPT=1)
    â†“ OR manual approval
Fact (active)
    â†“ (revoke/archive)
Fact (inactive)
    â†“ (reactivate)
Fact (active)
```

**Conflict Resolution**:
- Single-value keys -> **overwrite_latest**
- Multi-value keys (ends with `[]`) -> **keep_both**

---

## ðŸš¨ SAFETY BOUNDARIES (Immutable)

From `agent/policies/default.yaml` -> security_boundaries:

1. **Cannot modify policies file itself** (agent/policies/default.yaml)
2. **Cannot bypass WriteGate** (all code changes must be reviewed)
3. **Cannot disable audit logging**
4. **Cannot expose secrets in logs**
5. **Skills must run with --network=none** (Phase 1)

**Exception**: Explicit user command only

---

## ðŸ’¡ BEST PRACTICES

### DO:
- âœ… Read architecture docs before asking
- âœ… Check policies before acting
- âœ… Generate ChangePlan for code mods
- âœ… Cite sources ("From agent/architecture.md...")
- âœ… Explain reasoning with confidence scores

### DON'T:
- âŒ Modify forbidden_paths
- âŒ Bypass WriteGate
- âŒ Make assumptions (verify with docs)
- âŒ Edit projections manually (regenerate instead)

---

## ðŸ“š WORKFLOWS (Example Patterns)

Available workflows in `agent/workflows/`:
- `add_web_provider.md` - Add new search backend
- `debug_memory_issue.md` - Diagnose memory problems
- `self_improvement_proposal.md` - Propose AI improvements

**Note**: Workflows are **reference patterns**, not strict instructions. Adapt based on context.

---

## ðŸ”— FURTHER READING

- **Project Goals**: `agent/project.md`
- **Architecture Deep Dive**: `agent/architecture.md`
- **Complete Policies**: `agent/policies/default.yaml`
- **Workflows**: `agent/workflows/*.md`

---

**Projection Source**: agent/ cognition layer
**Regenerate**: `python scripts/generate_projections.py`
**Modification Protocol**: Edit agent/ -> Regenerate projections
"""

    output_path = OUTPUT_DIR / "AGENTS.md"
    output_path.write_text(output, encoding="utf-8")
    print(f"[OK] Generated: {output_path}")


def generate_claude_md():
    """Generate CLAUDE.md - Claude Code specific instructions."""

    print("Generating CLAUDE.md...")

    # Read sources
    project_content = read_file(AGENT_DIR / "project.md")
    architecture_content = read_file(AGENT_DIR / "architecture.md")
    policies_path = AGENT_DIR / "policies" / "default.yaml"

    project_meta = extract_yaml_frontmatter(project_content)
    policies = read_yaml_file(policies_path)

    output = f"""# Claude Code Instructions for LonelyCat

> **Auto-generated** from `agent/` cognition layer
> **Last Updated**: {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}
> **[WARN]ï¸ DO NOT EDIT** - Regenerate with `python scripts/generate_projections.py`

---

## ðŸ¤– You Are Working On

**Project**: {project_meta.get('project_name', 'LonelyCat')} - {project_meta.get('tagline', 'Self-Evolving Local AgentOS')}
**Current Phase**: {project_meta.get('phase', 'Phase 0 - Cognitive Layer')}
**Your Role**: {project_meta.get('ai_role', 'Code assistant with cognition-driven constraints')}

---

## ðŸŽ¯ Quick Start (Read This First!)

1. **Read cognition layer**: Check `agent/README.md` -> `agent/project.md` -> `agent/architecture.md`
2. **Understand constraints**: Read `agent/policies/default.yaml`
3. **Before modifying code**: Generate ChangePlan (Phase 1+) or explain changes (Phase 0)
4. **When stuck**: Query `agent/architecture.md` -> "HOW TO QUERY"

---

## ðŸš« NEVER DO (Critical!)

```yaml
# From agent/policies/default.yaml -> forbidden_paths
{yaml.dump(policies.get('forbidden_paths', [])[:10], default_flow_style=False)}
# ... (see full list in agent/policies/default.yaml)
```

**Violation = Immediate abort**

---

## ðŸ“ BEFORE MODIFYING CODE

### Phase 0 (Current)
```
You CANNOT modify code directly. Instead:
1. Explain what should be changed
2. Generate a patch preview
3. User applies manually
```

### Phase 1+ (WriteGate Available)
```
1. Create ChangePlan:
   - objective: "Fix bug in memory acceptance"
   - affected_files: ["packages/memory/memory.py"]
   - risk_assessment: "LOW"
   - rollback_plan: "Git revert + restart"

2. User approves plan

3. Generate ChangeSet (unified diff)

4. User approves diff

5. System applies atomically
```

---

## ðŸ—ï¸ Architecture Quick Reference

### 5 Layers
```
Cognitive (agent/)        â† Where you learn about project
    â†“
Orchestration (core-api)  â† Agent Loop, WriteGate
    â†“
Execution (agent-worker)  â† LLM calls, tool execution
    â†“
Memory (packages/memory)  â† Proposal -> Fact lifecycle
    â†“
Infrastructure (DB/Docker) â† SQLite, sandbox
```

### Critical Invariants
- Core API **never calls LLM** (delegates to agent-worker)
- Skills **run in Docker** with `--network=none`
- All state changes **audited** (audit_events table)
- Facts scoped: **global | project | session**

---

## ðŸ” Finding Code

**Where is X implemented?**
```
1. Check agent/architecture.md -> "Where to Find Things"
2. Use Grep: Grep(pattern="accept_proposal", path="packages/memory")
3. Read source: Read packages/memory/memory.py
```

**Common Locations**:
- Memory logic: `packages/memory/memory.py`
- Agent Loop: `packages/runtime/agent_loop.py`
- Skills: `apps/core-api/app/api/sandbox.py`
- Settings: `apps/core-api/app/api/settings.py`

---

## âš–ï¸ Permission Checks (Run Before Acting)

```python
# 1. Forbidden?
if path in forbidden_paths:
    ABORT("Path is forbidden")

# 2. Risk level?
if operation == "modify_code":
    risk = "write"  # L1 - approval required

# 3. WriteGate needed?
if path.match("apps/**/*.py"):
    create_change_plan()
```

---

## ðŸ’¾ Memory System

### Proposal -> Fact Flow
```
Agent detects: "User likes matcha" (confidence=0.9)
    â†“
POST /memory/proposals
    â†“
AUTO_ACCEPT? (confidence >= 0.85 + env var)
    â†“ YES
Accept -> Create Fact (scope=global, status=active)
    â†“
Inject into LLM system message on next turn
```

### Conflict Resolution
- Key `user.likes` (single-value) -> **overwrite_latest**
- Key `favorite_tools[]` (multi-value) -> **keep_both**

---

## ðŸ› ï¸ Useful Commands

**Run Tests**:
```powershell
.\\scripts\\test-py.ps1  # Windows
make test-py             # Linux/Mac
```

**Start Services**:
```powershell
.\\scripts\\up.ps1       # Windows
make up                  # Linux/Mac
```

**Check Settings**:
```bash
curl http://localhost:5173/settings | jq
```

**Query Memory**:
```bash
curl http://localhost:5173/memory/facts/active | jq
```

---

## ðŸ“š Workflows (Context-Specific Guides)

- **Adding web provider**: `agent/workflows/add_web_provider.md`
- **Debugging memory**: `agent/workflows/debug_memory_issue.md`
- **Self-improvement**: `agent/workflows/self_improvement_proposal.md`

**Use workflows as patterns**, not rigid steps. Adapt to context.

---

## ðŸš¨ When You're Stuck

**Level 1**: Re-read cognition docs
- `agent/README.md` (overview)
- `agent/architecture.md` (structure)
- `agent/policies/default.yaml` (rules)

**Level 2**: Trace through code
- Use architecture.md -> "Where to Find Things"
- Read actual implementation
- Follow data flow diagrams

**Level 3**: Ask user
- Explain what you know
- Explain what's ambiguous
- Ask **specific** question (not "what should I do?")

---

## ðŸ’¡ Pro Tips

1. **Always cite sources**: "From agent/architecture.md -> DATA FLOW..."
2. **Check policies first**: Don't assume, verify
3. **Risk-aware by default**: Code change? Think WriteGate
4. **Emergent workflows**: Infer from architecture when workflow missing
5. **Confidence scores**: Include in proposals (0.0-1.0)

---

## ðŸ”— Related Files

- Full architecture: `agent/architecture.md`
- Complete policies: `agent/policies/default.yaml`
- All workflows: `agent/workflows/*.md`
- Generic instructions: `AGENTS.md`

---

**Regenerate**: `python scripts/generate_projections.py`
**Edit Source**: `agent/*` (never edit projections directly)
**Your Advantage**: You have full cognition layer context - use it!
"""

    output_path = OUTPUT_DIR / "CLAUDE.md"
    output_path.write_text(output, encoding="utf-8")
    print(f"[OK] Generated: {output_path}")


def generate_cursor_rules():
    """Generate .cursor/rules/ - Cursor IDE specific rules."""

    print("Generating .cursor/rules/...")

    # Create directory
    cursor_dir = OUTPUT_DIR / ".cursor" / "rules"
    cursor_dir.mkdir(parents=True, exist_ok=True)

    # Read sources
    architecture_content = read_file(AGENT_DIR / "architecture.md")
    policies_path = AGENT_DIR / "policies" / "default.yaml"
    policies = read_yaml_file(policies_path)

    # Generate architecture.mdc
    arch_rules = f"""# LonelyCat Architecture Rules
# Auto-generated from agent/architecture.md
# Last Updated: {datetime.now().strftime("%Y-%m-%d")}

## System Overview

LonelyCat is a 5-layer Self-Evolving AgentOS:

1. **Cognitive Layer** (agent/) - AI self-awareness
2. **Orchestration Layer** (core-api) - Agent Loop, WriteGate
3. **Execution Layer** (agent-worker) - Tool execution
4. **Memory Layer** (packages/memory) - Proposal -> Fact
5. **Infrastructure Layer** - DB, Docker, UI

## Critical Invariants

- Core API never calls LLM directly (delegate to agent-worker)
- Skills execute in Docker sandbox (--network=none)
- All state changes audited (audit_events table)
- Memory scoped: global | project | session

## Where to Find Things

- Memory Proposal logic: packages/memory/memory.py -> MemoryStore.accept_proposal()
- Agent Loop: packages/runtime/agent_loop.py -> AgentLoop.handle()
- Skills validation: apps/core-api/app/api/skills.py
- Facts injection: apps/agent-worker/worker/responder.py -> _build_system_message()

## Before Modifying Code

1. Check if path in forbidden_paths (agent/policies/default.yaml)
2. Determine risk level (read_only/write/execute/destructive)
3. Generate ChangePlan if modifying apps/**/*.py or packages/**/*.py
4. Run tests: .\\scripts\\test-py.ps1 (Windows) or make test-py (Linux/Mac)
"""

    (cursor_dir / "architecture.mdc").write_text(arch_rules, encoding="utf-8")
    print(f"[OK] Generated: {cursor_dir / 'architecture.mdc'}")

    # Generate policies.mdc
    policy_rules = f"""# LonelyCat Safety Policies
# Auto-generated from agent/policies/default.yaml
# Last Updated: {datetime.now().strftime("%Y-%m-%d")}

## Forbidden Paths (Never Modify)

{chr(10).join(f"- {path}" for path in policies.get('forbidden_paths', []))}

Violation: Immediate abort + audit log

## Read-Only Paths (Need Approval)

{chr(10).join(f"- {path}" for path in policies.get('read_only_paths', [])[:10])}

(See full list in agent/policies/default.yaml)

## Risk Levels

### L0 - Read Only (No Approval)
- web.search, web.fetch, memory.list_facts
- read_file, list_directory

### L1 - Write (Approval Required)
- memory.propose, skill.python.run
- write_file, create_directory

### L2 - Execute (Always Approval)
- host.execute_command, host.apply_patch
- execute_shell, modify_database

### L3 - Destructive (Double Confirmation)
- host.delete_database, git.reset_hard
- drop_table, delete_branch

## WriteGate Rules (Phase 1+)

Triggers when modifying:
- apps/**/*.py, packages/**/*.py
- pyproject.toml, package.json
- Configuration files

Flow:
1. Create ChangePlan (objective, affected_files, risk, rollback)
2. User approves plan
3. Generate ChangeSet (diffs)
4. User approves diffs
5. Apply atomically
6. Verify (tests pass)

## Security Boundaries (Immutable)

- Cannot modify agent/policies/default.yaml (this file's source)
- Cannot bypass WriteGate
- Cannot disable audit logging
- Cannot expose secrets in logs
- Skills must use --network=none (Phase 1)
"""

    (cursor_dir / "policies.mdc").write_text(policy_rules, encoding="utf-8")
    print(f"[OK] Generated: {cursor_dir / 'policies.mdc'}")


def main():
    """Generate all projections."""
    print("=" * 60)
    print("LonelyCat Projection Tool - Cognition Compiler")
    print("=" * 60)
    print()

    print(f"Source: {AGENT_DIR}")
    print(f"Output: {OUTPUT_DIR}")
    print()

    try:
        generate_agents_md()
        generate_claude_md()
        generate_cursor_rules()

        print()
        print("=" * 60)
        print("[OK] All projections generated successfully!")
        print("=" * 60)
        print()
        print("Generated files:")
        print("  - AGENTS.md (generic agent instructions)")
        print("  - CLAUDE.md (Claude Code specific)")
        print("  - .cursor/rules/architecture.mdc (Cursor IDE)")
        print("  - .cursor/rules/policies.mdc (Cursor IDE)")
        print()
        print("[WARN]ï¸  These files are READ-ONLY")
        print("    To update: Edit agent/* -> Re-run this script")
        print()

    except Exception as e:
        print(f"\nError: {e}")
        import traceback
        traceback.print_exc()
        return 1

    return 0


if __name__ == "__main__":
    exit(main())
