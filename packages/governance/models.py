"""
LonelyCat Governance Models

Data structures for WriteGate governance system.
These are governance artifacts, not execution commands.

Key Principles:
- ChangePlan = structured intent (governance artifact)
- ChangeSet = structured diff (what will be applied)
- GovernanceDecision = WriteGate verdict (ALLOW/NEED_APPROVAL/DENY)
- WriteGate evaluates, does NOT execute
"""

from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import List, Optional
import hashlib
import json


class RiskLevel(Enum):
    """Risk level for changes."""
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"

    def __lt__(self, other):
        """Support max() comparison."""
        order = [RiskLevel.LOW, RiskLevel.MEDIUM, RiskLevel.HIGH, RiskLevel.CRITICAL]
        return order.index(self) < order.index(other)

    def __le__(self, other):
        return self < other or self == other

    def __gt__(self, other):
        return not self <= other

    def __ge__(self, other):
        return not self < other


class Verdict(Enum):
    """WriteGate evaluation verdict."""
    ALLOW = "allow"                  # Can proceed without human approval
    NEED_APPROVAL = "need_approval"  # Requires human review
    DENY = "deny"                    # Blocked by policy


class Operation(Enum):
    """File operation type."""
    CREATE = "create"
    UPDATE = "update"
    DELETE = "delete"


@dataclass
class ChangePlan:
    """
    Governance artifact: structured intent of modification.

    NOT an execution command - describes WHAT and WHY, not HOW.
    Generated by Planner/Agent, evaluated by WriteGate.
    """
    id: str

    # Core Intent (What & Why)
    intent: str              # "Fix memory conflict resolution bug"
    objective: str           # "Add semantic similarity check"
    rationale: str           # "Current logic too simplistic (30% conflicts)"

    # Scope (Where)
    affected_paths: List[str]  # ["packages/memory/facts.py"]

    # Risk Assessment (SPLIT to prevent LLM cheating)
    risk_level_proposed: RiskLevel   # From LLM/Agent

    # Verification Plans (How to validate & rollback)
    rollback_plan: str       # "git revert <commit> && restart services"
    verification_plan: str   # "Run test_memory.py, check GET /health"

    # Metadata
    created_by: str          # "agent" | "user" | "agent_worker_123"
    created_at: datetime
    confidence: float        # 0.0-1.0 (AI's confidence in this plan)

    # Optional fields with defaults
    dependencies: List[str] = field(default_factory=list)  # Other plan IDs
    risk_level_effective: Optional[RiskLevel] = None  # From WriteGate (may escalate)
    risk_escalation_reason: Optional[str] = None
    health_checks: List[str] = field(default_factory=list)  # ["GET /health returns 200"]
    policy_refs: List[str] = field(default_factory=list)  # ["writegate_rules", "risk_levels"]
    run_id: Optional[str] = None  # Link to agent run that created this

    def to_dict(self) -> dict:
        """Serialize to dict for JSON/DB storage."""
        return {
            "id": self.id,
            "intent": self.intent,
            "objective": self.objective,
            "rationale": self.rationale,
            "affected_paths": self.affected_paths,
            "dependencies": self.dependencies,
            "risk_level_proposed": self.risk_level_proposed.value,
            "risk_level_effective": self.risk_level_effective.value if self.risk_level_effective else None,
            "risk_escalation_reason": self.risk_escalation_reason,
            "rollback_plan": self.rollback_plan,
            "verification_plan": self.verification_plan,
            "health_checks": self.health_checks,
            "policy_refs": self.policy_refs,
            "created_by": self.created_by,
            "created_at": self.created_at.isoformat(),
            "confidence": self.confidence,
            "run_id": self.run_id
        }

    @classmethod
    def from_dict(cls, data: dict) -> "ChangePlan":
        """Deserialize from dict."""
        return cls(
            id=data["id"],
            intent=data["intent"],
            objective=data["objective"],
            rationale=data["rationale"],
            affected_paths=data["affected_paths"],
            dependencies=data.get("dependencies", []),
            risk_level_proposed=RiskLevel(data["risk_level_proposed"]),
            risk_level_effective=RiskLevel(data["risk_level_effective"]) if data.get("risk_level_effective") else None,
            risk_escalation_reason=data.get("risk_escalation_reason"),
            rollback_plan=data["rollback_plan"],
            verification_plan=data["verification_plan"],
            health_checks=data.get("health_checks", []),
            policy_refs=data.get("policy_refs", []),
            created_by=data["created_by"],
            created_at=datetime.fromisoformat(data["created_at"]),
            confidence=data["confidence"],
            run_id=data.get("run_id")
        )


@dataclass
class FileChange:
    """
    Single file modification (structured diff).

    This is NOT a shell command - it's a data structure describing the change.
    """
    operation: Operation
    path: str

    # Content (for CREATE/UPDATE/DELETE)
    old_content: Optional[str] = None  # None for CREATE
    new_content: Optional[str] = None  # None for DELETE

    # Hashes (integrity check)
    old_hash: Optional[str] = None     # SHA256(old_content)
    new_hash: Optional[str] = None     # SHA256(new_content)

    # Diff representation
    diff_unified: str = ""             # Unified diff format (for display)

    # Metrics
    line_count_delta: int = 0          # +10, -5, etc
    size_bytes: int = 0

    def compute_hashes(self):
        """Compute SHA256 hashes for content."""
        if self.old_content:
            self.old_hash = hashlib.sha256(self.old_content.encode()).hexdigest()
        if self.new_content:
            self.new_hash = hashlib.sha256(self.new_content.encode()).hexdigest()

    def to_dict(self) -> dict:
        """Serialize to dict."""
        return {
            "operation": self.operation.value,
            "path": self.path,
            "old_content": self.old_content,
            "new_content": self.new_content,
            "old_hash": self.old_hash,
            "new_hash": self.new_hash,
            "diff_unified": self.diff_unified,
            "line_count_delta": self.line_count_delta,
            "size_bytes": self.size_bytes
        }

    @classmethod
    def from_dict(cls, data: dict) -> "FileChange":
        """Deserialize from dict."""
        return cls(
            operation=Operation(data["operation"]),
            path=data["path"],
            old_content=data.get("old_content"),
            new_content=data.get("new_content"),
            old_hash=data.get("old_hash"),
            new_hash=data.get("new_hash"),
            diff_unified=data.get("diff_unified", ""),
            line_count_delta=data.get("line_count_delta", 0),
            size_bytes=data.get("size_bytes", 0)
        )


@dataclass
class ChangeSet:
    """
    Structured diff - collection of file changes.

    Generated by Planner/Agent (NOT WriteGate).
    WriteGate evaluates this along with ChangePlan.
    """
    id: str
    plan_id: str               # References ChangePlan.id
    changes: List[FileChange]
    checksum: str              # SHA256(changes) - prevents tampering

    # Metadata
    generated_by: str          # "agent" | "user"
    generated_at: datetime

    def compute_checksum(self):
        """Compute checksum of all changes (tamper detection)."""
        changes_json = json.dumps(
            [c.to_dict() for c in self.changes],
            sort_keys=True
        )
        self.checksum = hashlib.sha256(changes_json.encode()).hexdigest()

    def verify_checksum(self) -> bool:
        """Verify checksum matches current changes."""
        changes_json = json.dumps(
            [c.to_dict() for c in self.changes],
            sort_keys=True
        )
        computed = hashlib.sha256(changes_json.encode()).hexdigest()
        return computed == self.checksum

    def total_lines_changed(self) -> int:
        """Total lines added + removed."""
        return sum(abs(c.line_count_delta) for c in self.changes)

    def to_dict(self) -> dict:
        """Serialize to dict."""
        return {
            "id": self.id,
            "plan_id": self.plan_id,
            "changes": [c.to_dict() for c in self.changes],
            "checksum": self.checksum,
            "generated_by": self.generated_by,
            "generated_at": self.generated_at.isoformat()
        }

    @classmethod
    def from_dict(cls, data: dict) -> "ChangeSet":
        """Deserialize from dict."""
        return cls(
            id=data["id"],
            plan_id=data["plan_id"],
            changes=[FileChange.from_dict(c) for c in data["changes"]],
            checksum=data["checksum"],
            generated_by=data["generated_by"],
            generated_at=datetime.fromisoformat(data["generated_at"])
        )


@dataclass
class GovernanceDecision:
    """
    WriteGate evaluation result.

    This is the output of WriteGate.evaluate(plan, changeset).
    Contains verdict, reasons, and audit metadata.
    """
    id: str
    plan_id: str
    changeset_id: str

    # Verdict
    verdict: Verdict
    reasons: List[str]         # Machine-readable reasons
    suggestions: List[str] = field(default_factory=list)  # Phase 2.5-C: reflection hints (not mixed into reasons)

    # Effective Risk (computed by WriteGate)
    risk_level_effective: RiskLevel

    # Audit Metadata (CRITICAL for debugging/replay)
    policy_snapshot_hash: str      # Hash of policies/default.yaml
    agent_source_hash: str         # Hash of agent/ directory
    writegate_version: str         # "1.0.0"

    evaluated_at: datetime
    evaluator: str             # "writegate_engine"

    # Optional fields with defaults
    violated_policies: List[str] = field(default_factory=list)
    required_actions: List[str] = field(default_factory=list)  # ["user_review", "add_tests"]
    projection_hash: Optional[str] = None  # Hash of AGENTS.md etc (optional)
    # Phase 2.4-C: reflection hints audit (hints affect reasons only, not verdict)
    reflection_hints_used: bool = False
    hints_digest: Optional[str] = None

    def to_dict(self) -> dict:
        """Serialize to dict."""
        d = {
            "id": self.id,
            "plan_id": self.plan_id,
            "changeset_id": self.changeset_id,
            "verdict": self.verdict.value,
            "reasons": self.reasons,
            "suggestions": self.suggestions,
            "violated_policies": self.violated_policies,
            "required_actions": self.required_actions,
            "risk_level_effective": self.risk_level_effective.value,
            "policy_snapshot_hash": self.policy_snapshot_hash,
            "agent_source_hash": self.agent_source_hash,
            "projection_hash": self.projection_hash,
            "writegate_version": self.writegate_version,
            "evaluated_at": self.evaluated_at.isoformat(),
            "evaluator": self.evaluator
        }
        if self.reflection_hints_used:
            d["reflection_hints_used"] = True
            d["hints_digest"] = self.hints_digest
        return d

    @classmethod
    def from_dict(cls, data: dict) -> "GovernanceDecision":
        """Deserialize from dict."""
        return cls(
            id=data["id"],
            plan_id=data["plan_id"],
            changeset_id=data["changeset_id"],
            verdict=Verdict(data["verdict"]),
            reasons=data["reasons"],
            suggestions=data.get("suggestions", []),
            violated_policies=data.get("violated_policies", []),
            required_actions=data.get("required_actions", []),
            risk_level_effective=RiskLevel(data["risk_level_effective"]),
            policy_snapshot_hash=data["policy_snapshot_hash"],
            agent_source_hash=data["agent_source_hash"],
            projection_hash=data.get("projection_hash"),
            writegate_version=data["writegate_version"],
            evaluated_at=datetime.fromisoformat(data["evaluated_at"]),
            evaluator=data["evaluator"],
            reflection_hints_used=data.get("reflection_hints_used", False),
            hints_digest=data.get("hints_digest")
        )

    def is_approved(self) -> bool:
        """Check if verdict allows execution."""
        return self.verdict == Verdict.ALLOW

    def needs_user_approval(self) -> bool:
        """Check if requires human approval."""
        return self.verdict == Verdict.NEED_APPROVAL

    def is_denied(self) -> bool:
        """Check if blocked by policy."""
        return self.verdict == Verdict.DENY


@dataclass
class GovernanceApproval:
    """
    Human approval record for a ChangePlan.

    Created when user approves a NEED_APPROVAL decision.
    """
    id: str
    plan_id: str
    decision_id: str

    approved_by: str          # User ID/name
    approved_at: datetime
    approval_notes: Optional[str] = None  # User's comments

    def to_dict(self) -> dict:
        """Serialize to dict."""
        return {
            "id": self.id,
            "plan_id": self.plan_id,
            "decision_id": self.decision_id,
            "approved_by": self.approved_by,
            "approved_at": self.approved_at.isoformat(),
            "approval_notes": self.approval_notes
        }

    @classmethod
    def from_dict(cls, data: dict) -> "GovernanceApproval":
        """Deserialize from dict."""
        return cls(
            id=data["id"],
            plan_id=data["plan_id"],
            decision_id=data["decision_id"],
            approved_by=data["approved_by"],
            approved_at=datetime.fromisoformat(data["approved_at"]),
            approval_notes=data.get("approval_notes")
        )


# Helper functions

def generate_plan_id() -> str:
    """Generate unique ChangePlan ID."""
    import uuid
    return f"plan_{uuid.uuid4().hex[:12]}"


def generate_changeset_id() -> str:
    """Generate unique ChangeSet ID."""
    import uuid
    return f"cs_{uuid.uuid4().hex[:12]}"


def generate_decision_id() -> str:
    """Generate unique GovernanceDecision ID."""
    import uuid
    return f"dec_{uuid.uuid4().hex[:12]}"


def generate_approval_id() -> str:
    """Generate unique GovernanceApproval ID."""
    import uuid
    return f"appr_{uuid.uuid4().hex[:12]}"
