"""
LonelyCat Governance API Endpoints

Provides HTTP API for WriteGate governance system:
- POST /governance/plans - Submit ChangePlan
- POST /governance/changesets - Submit ChangeSet
- POST /governance/evaluations - Evaluate with WriteGate
- POST /governance/plans/{id}/approvals - Approve a plan
- GET /governance/plans/{id} - Retrieve plan details
- GET /governance/decisions/{id} - Retrieve decision

Philosophy:
- Governance endpoints are separate from execution
- WriteGate evaluates but does NOT apply changes
- Phase 1 MVP: no automatic execution (Phase 2 Host Executor)
"""

from fastapi import APIRouter, HTTPException
from pydantic import BaseModel, Field
from typing import List, Optional
from datetime import datetime
from pathlib import Path

# Add packages to path
import sys
sys.path.insert(0, str(Path(__file__).parent.parent.parent.parent / "packages"))

from governance import (
    ChangePlan,
    ChangeSet,
    GovernanceDecision,
    GovernanceApproval,
    WriteGate,
    RiskLevel,
    Verdict,
    generate_approval_id,
    compute_agent_source_hash,
    compute_projection_hash
)
from governance.storage import GovernanceStore


router = APIRouter(prefix="/governance", tags=["governance"])

# Initialize WriteGate and storage
writegate = WriteGate()
store = GovernanceStore()


# ==================== Request/Response Models ====================

class CreatePlanRequest(BaseModel):
    """Request to create ChangePlan."""
    intent: str
    objective: str
    rationale: str
    affected_paths: List[str]
    dependencies: List[str] = []
    risk_level_proposed: str  # 'low'|'medium'|'high'|'critical'
    rollback_plan: str
    verification_plan: str
    health_checks: List[str] = []
    policy_refs: List[str] = []
    created_by: str
    confidence: float
    run_id: Optional[str] = None


class CreateChangeSetRequest(BaseModel):
    """Request to create ChangeSet."""
    plan_id: str
    changes: List[dict]  # List of FileChange dicts
    generated_by: str


class EvaluateRequest(BaseModel):
    """Request to evaluate plan+changeset."""
    plan_id: str
    changeset_id: str


class ApproveRequest(BaseModel):
    """Request to approve a plan."""
    plan_id: str
    decision_id: str
    approved_by: str
    approval_notes: Optional[str] = None


# ==================== Endpoints ====================

@router.post("/plans")
async def create_plan(req: CreatePlanRequest):
    """
    Create a new ChangePlan.

    This is step 1 of the WriteGate flow:
    1. Agent generates ChangePlan (intent + scope + risk)
    2. Agent generates ChangeSet (diffs)
    3. WriteGate evaluates both -> verdict
    4. If NEED_APPROVAL, human approves
    """
    try:
        # Parse risk level
        risk_level = RiskLevel(req.risk_level_proposed)
    except ValueError:
        raise HTTPException(
            status_code=400,
            detail=f"Invalid risk_level_proposed: {req.risk_level_proposed}"
        )

    # Create ChangePlan
    from governance import generate_plan_id
    plan = ChangePlan(
        id=generate_plan_id(),
        intent=req.intent,
        objective=req.objective,
        rationale=req.rationale,
        affected_paths=req.affected_paths,
        dependencies=req.dependencies,
        risk_level_proposed=risk_level,
        rollback_plan=req.rollback_plan,
        verification_plan=req.verification_plan,
        health_checks=req.health_checks,
        policy_refs=req.policy_refs,
        created_by=req.created_by,
        created_at=datetime.utcnow(),
        confidence=req.confidence,
        run_id=req.run_id
    )

    # Save to database
    store.save_plan(plan)

    return {
        "plan": plan.to_dict(),
        "message": "ChangePlan created successfully"
    }


@router.post("/changesets")
async def create_changeset(req: CreateChangeSetRequest):
    """
    Create a new ChangeSet (structured diff).

    This is step 2 of the WriteGate flow.
    ChangeSet is generated by Agent/Planner, not WriteGate.
    """
    # Verify plan exists
    plan = store.get_plan(req.plan_id)
    if not plan:
        raise HTTPException(
            status_code=404,
            detail=f"Plan not found: {req.plan_id}"
        )

    # Parse FileChange objects
    from governance import FileChange, Operation, generate_changeset_id
    changes = []
    for change_dict in req.changes:
        change = FileChange(
            operation=Operation(change_dict["operation"]),
            path=change_dict["path"],
            old_content=change_dict.get("old_content"),
            new_content=change_dict.get("new_content"),
            old_hash=change_dict.get("old_hash"),
            new_hash=change_dict.get("new_hash"),
            diff_unified=change_dict.get("diff_unified", ""),
            line_count_delta=change_dict.get("line_count_delta", 0),
            size_bytes=change_dict.get("size_bytes", 0)
        )
        changes.append(change)

    # Create ChangeSet
    changeset = ChangeSet(
        id=generate_changeset_id(),
        plan_id=req.plan_id,
        changes=changes,
        checksum="",  # Will be computed
        generated_by=req.generated_by,
        generated_at=datetime.utcnow()
    )

    # Compute checksum
    changeset.compute_checksum()

    # Save to database
    store.save_changeset(changeset)

    return {
        "changeset": changeset.to_dict(),
        "message": "ChangeSet created successfully"
    }


@router.post("/evaluations")
async def evaluate(req: EvaluateRequest):
    """
    Evaluate ChangePlan + ChangeSet with WriteGate.

    This is step 3 of the WriteGate flow.
    WriteGate evaluates both artifacts and returns verdict.

    Returns:
        GovernanceDecision with verdict (ALLOW/NEED_APPROVAL/DENY)
    """
    # Retrieve plan and changeset
    plan = store.get_plan(req.plan_id)
    if not plan:
        raise HTTPException(
            status_code=404,
            detail=f"Plan not found: {req.plan_id}"
        )

    changeset = store.get_changeset(req.changeset_id)
    if not changeset:
        raise HTTPException(
            status_code=404,
            detail=f"ChangeSet not found: {req.changeset_id}"
        )

    # Verify plan and changeset are linked
    if changeset.plan_id != plan.id:
        raise HTTPException(
            status_code=400,
            detail=f"ChangeSet {changeset.id} is not linked to plan {plan.id}"
        )

    # Verify changeset checksum
    if not changeset.verify_checksum():
        raise HTTPException(
            status_code=400,
            detail="ChangeSet checksum verification failed (possible tampering)"
        )

    # Compute audit metadata
    repo_root = Path(__file__).parent.parent.parent.parent
    agent_dir = repo_root / "agent"
    agent_source_hash = compute_agent_source_hash(agent_dir) if agent_dir.exists() else None

    projection_files = [
        repo_root / "AGENTS.md",
        repo_root / "CLAUDE.md"
    ]
    projection_hash = compute_projection_hash(projection_files)

    # Evaluate with WriteGate
    decision = writegate.evaluate(
        plan=plan,
        changeset=changeset,
        agent_source_hash=agent_source_hash,
        projection_hash=projection_hash
    )

    # Update plan with effective risk level (if escalated)
    if decision.risk_level_effective != plan.risk_level_proposed:
        plan.risk_level_effective = decision.risk_level_effective
        plan.risk_escalation_reason = "; ".join(
            r for r in decision.reasons if "Risk escalated" in r
        )
        # Note: In Phase 1 MVP, we don't update DB (append-only)
        # Risk escalation is recorded in decision

    # Save decision to database
    store.save_decision(decision)

    return {
        "decision": decision.to_dict(),
        "verdict": decision.verdict.value,
        "is_approved": decision.is_approved(),
        "needs_user_approval": decision.needs_user_approval(),
        "is_denied": decision.is_denied(),
        "message": f"WriteGate evaluation complete: {decision.verdict.value}"
    }


@router.post("/plans/{plan_id}/approvals")
async def approve_plan(plan_id: str, req: ApproveRequest):
    """
    Approve a ChangePlan (human approval).

    This is step 4 of the WriteGate flow (if verdict=NEED_APPROVAL).
    User reviews plan+changeset and provides approval.

    Note: Phase 1 MVP does NOT execute the change.
    Execution will be added in Phase 2 (Host Executor).
    """
    # Verify plan exists
    plan = store.get_plan(plan_id)
    if not plan:
        raise HTTPException(
            status_code=404,
            detail=f"Plan not found: {plan_id}"
        )

    # Verify decision exists
    decision = store.get_decision(req.decision_id)
    if not decision:
        raise HTTPException(
            status_code=404,
            detail=f"Decision not found: {req.decision_id}"
        )

    # Verify decision is for this plan
    if decision.plan_id != plan_id:
        raise HTTPException(
            status_code=400,
            detail=f"Decision {req.decision_id} is not for plan {plan_id}"
        )

    # Check if already approved
    existing_approval = store.get_approval_for_plan(plan_id)
    if existing_approval:
        return {
            "approval": existing_approval.to_dict(),
            "message": "Plan already approved"
        }

    # Check if decision requires approval
    if decision.verdict == Verdict.DENY:
        raise HTTPException(
            status_code=400,
            detail="Cannot approve a DENIED plan"
        )

    # Create approval record
    approval = GovernanceApproval(
        id=generate_approval_id(),
        plan_id=plan_id,
        decision_id=req.decision_id,
        approved_by=req.approved_by,
        approved_at=datetime.utcnow(),
        approval_notes=req.approval_notes
    )

    # Save to database
    store.save_approval(approval)

    return {
        "approval": approval.to_dict(),
        "message": "Plan approved successfully",
        "note": "Phase 1 MVP: Approval recorded, but changes NOT executed (Phase 2 Host Executor)"
    }


@router.get("/plans/{plan_id}")
async def get_plan(plan_id: str):
    """Retrieve ChangePlan by ID."""
    plan = store.get_plan(plan_id)
    if not plan:
        raise HTTPException(
            status_code=404,
            detail=f"Plan not found: {plan_id}"
        )

    return {"plan": plan.to_dict()}


@router.get("/changesets/{changeset_id}")
async def get_changeset(changeset_id: str):
    """Retrieve ChangeSet by ID."""
    changeset = store.get_changeset(changeset_id)
    if not changeset:
        raise HTTPException(
            status_code=404,
            detail=f"ChangeSet not found: {changeset_id}"
        )

    return {"changeset": changeset.to_dict()}


@router.get("/decisions/{decision_id}")
async def get_decision(decision_id: str):
    """Retrieve GovernanceDecision by ID."""
    decision = store.get_decision(decision_id)
    if not decision:
        raise HTTPException(
            status_code=404,
            detail=f"Decision not found: {decision_id}"
        )

    return {"decision": decision.to_dict()}


@router.get("/plans/{plan_id}/full")
async def get_full_record(plan_id: str):
    """
    Get complete governance record for a plan.

    Returns plan, changeset, decision, and approval (if exists).
    """
    record = store.get_full_governance_record(plan_id)

    if not record["plan"]:
        raise HTTPException(
            status_code=404,
            detail=f"Plan not found: {plan_id}"
        )

    return {
        "plan": record["plan"].to_dict() if record["plan"] else None,
        "changeset": record["changeset"].to_dict() if record["changeset"] else None,
        "decision": record["decision"].to_dict() if record["decision"] else None,
        "approval": record["approval"].to_dict() if record["approval"] else None
    }


@router.get("/plans")
async def list_plans(
    created_by: Optional[str] = None,
    risk_level: Optional[str] = None,
    limit: int = 50
):
    """List ChangePlans with optional filters."""
    plans = store.list_plans(
        created_by=created_by,
        risk_level=risk_level,
        limit=limit
    )

    return {
        "plans": [p.to_dict() for p in plans],
        "count": len(plans)
    }


@router.get("/decisions")
async def list_decisions(
    verdict: Optional[str] = None,
    limit: int = 50
):
    """List GovernanceDecisions with optional filters."""
    verdict_enum = None
    if verdict:
        try:
            verdict_enum = Verdict(verdict)
        except ValueError:
            raise HTTPException(
                status_code=400,
                detail=f"Invalid verdict: {verdict}"
            )

    decisions = store.list_decisions(
        verdict=verdict_enum,
        limit=limit
    )

    return {
        "decisions": [d.to_dict() for d in decisions],
        "count": len(decisions)
    }
